{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Projeto Platforms, Microservices, DevOps and APIs - 2025.1","text":"<p>Bem-vindo ao projeto da disciplina. Este reposit\u00f3rio documenta o desenvolvimento de solu\u00e7\u00f5es com microservi\u00e7os, pr\u00e1ticas de DevOps e implanta\u00e7\u00e3o em nuvem usando Kubernetes (Minikube e AWS EKS).</p>"},{"location":"#repositorio-de-microservicos","title":"Reposit\u00f3rio de Microservi\u00e7os","text":"<p>Todos os microservi\u00e7os e artefatos de infraestrutura est\u00e3o dispon\u00edveis neste reposit\u00f3rio: https://github.com/henriquetg1/apis-exercicio-individual (No README desse reposit\u00f3rio constam os links para todos os microservi\u00e7os individuais da aplica\u00e7\u00e3o.)</p>"},{"location":"#integrantes-do-grupo","title":"Integrantes do Grupo","text":"<ul> <li>Gabriel Mendes</li> <li>Henrique Turco</li> </ul>"},{"location":"#estrutura-geral","title":"Estrutura Geral","text":"<ul> <li>Projeto em Grupo: Envolve como os microservi\u00e7os foram integrados, quais tecnologias de infraestrutura foram utilizadas e como o sistema foi implantado em ambiente de produ\u00e7\u00e3o com AWS EKS.  </li> <li>Projeto Individual: Cada integrante desenvolveu microservi\u00e7os isoladamente, seguindo especifica\u00e7\u00f5es de APIs REST autenticadas e integradas ao gateway. Cada servi\u00e7o incluiu endpoints funcionais, consumo de APIs externas, deploy com Minikube e EKS, al\u00e9m de pr\u00e1ticas de DevOps como CI/CD, monitoramento e tratamento de erros. As entregas individuais envolveram tamb\u00e9m documenta\u00e7\u00e3o completa com evid\u00eancias e v\u00eddeo de demonstra\u00e7\u00e3o.</li> </ul>"},{"location":"#agradecimentos","title":"Agradecimentos","text":"<p>Agradecemos \u00e0 equipe docente da disciplina e ao suporte t\u00e9cnico fornecido para o desenvolvimento do projeto.</p> <p>Documenta\u00e7\u00e3o desenvolvida para fins acad\u00eamicos - Insper 2025.1.</p>"},{"location":"projeto/","title":"Projeto em Grupo","text":""},{"location":"projeto/#visao-geral-do-projeto","title":"Vis\u00e3o Geral do Projeto","text":"<p>O projeto em grupo tem como objetivo aplicar pr\u00e1ticas modernas de desenvolvimento em nuvem, DevOps e microservi\u00e7os em um ambiente real de produ\u00e7\u00e3o usando a AWS. As entregas foram organizadas em etapas pr\u00e1ticas que abrangem desde a configura\u00e7\u00e3o da infraestrutura (AWS e EKS), testes de desempenho (HPA e carga), at\u00e9 o deploy automatizado com Jenkins (CI/CD). Al\u00e9m disso, cada grupo foi respons\u00e1vel por realizar uma an\u00e1lise de custos realista utilizando o AWS Pricing Calculator e calcular o uso de recursos com base em seu cluster. A entrega final inclui n\u00e3o apenas a implanta\u00e7\u00e3o funcional da aplica\u00e7\u00e3o via EKS e banco de dados com RDS, mas tamb\u00e9m a documenta\u00e7\u00e3o completa, uma apresenta\u00e7\u00e3o de storytelling visual e um v\u00eddeo de demonstra\u00e7\u00e3o entre 2 a 3 minutos. O projeto avalia tanto aspectos t\u00e9cnicos quanto de comunica\u00e7\u00e3o, destacando desafios enfrentados e pr\u00e1ticas de engenharia adotadas, como o uso de PaaS, testes de carga e automatiza\u00e7\u00e3o de pipelines. Cada etapa do projeto contribui para uma forma\u00e7\u00e3o s\u00f3lida em arquitetura de sistemas distribu\u00eddos, cloud computing e entrega cont\u00ednua.</p>"},{"location":"projeto/#objetivos","title":"Objetivos","text":"<ul> <li>Configurar a conta AWS para suportar o projeto.</li> <li>Provisionar e configurar corretamente o cluster EKS.</li> <li>Elaborar um plano de custos realista utilizando o AWS Pricing Calculator.</li> <li>Aplicar solu\u00e7\u00f5es PaaS para simplificar opera\u00e7\u00f5es (RDS, EKS, ECR).</li> <li>Garantir que todos os microservi\u00e7os estejam funcionando corretamente no ambiente de produ\u00e7\u00e3o.</li> </ul>"},{"location":"projeto/#arquitetura","title":"Arquitetura","text":"<ul> <li>API Gateway: Controla entrada e roteamento.</li> <li>Auth: Servi\u00e7o de autentica\u00e7\u00e3o com JWT.</li> <li>Exchange, Product, Order, Account: servi\u00e7os de dom\u00ednio.</li> <li>PostgreSQL: banco de dados usado pelos servi\u00e7os.</li> </ul>"},{"location":"projeto/#fluxo-de-requisicao","title":"Fluxo de requisi\u00e7\u00e3o","text":"<ol> <li>Login no Auth \u2192 recebe token JWT  </li> <li>Token usado no Gateway para acessar rotas protegidas  </li> <li>Gateway redireciona para Account, Order ou Product  </li> </ol>"},{"location":"projeto/#deploy","title":"Deploy","text":"<ul> <li>Minikube: usado em testes locais  </li> <li>EKS: usado na apresenta\u00e7\u00e3o final  </li> </ul> <p>Toda a infraestrutura foi gerenciada com <code>kubectl</code>, arquivos YAML e Helm quando aplic\u00e1vel.</p>"},{"location":"projeto/#configuracao-aws-e-eks","title":"Configura\u00e7\u00e3o AWS e EKS","text":"<p>Durante este projeto, n\u00f3s configuramos a conta AWS e provisionamos um cluster EKS. Abaixo, uma captura de tela do cluster em execu\u00e7\u00e3o:</p> <p></p> <p>Este cluster foi configurado para escalar automaticamente conforme a demanda usando Auto Scaling Groups e HPA.</p> <p>Endpoint da API em execu\u00e7\u00e3o: <pre><code>http://aef1f8f294b95439283d49dcde0dbde5-1733067101.sa-east-1.elb.amazonaws.com\n</code></pre></p>"},{"location":"projeto/#analise-de-custos","title":"An\u00e1lise de Custos","text":"<p>Utilizamos o AWS Pricing Calculator para gerar um plano de custo que reflete o uso estimado dos recursos no EKS:</p> <p></p> <p>Relat\u00f3rio Consolidado (PDF)    - Baixar An\u00e1lise de Custos (PDF) </p> <p>A proje\u00e7\u00e3o acima demonstra os custos mensais esperados para manter o ambiente dormindo e em uso.</p>"},{"location":"projeto/#paas","title":"PaaS","text":"<p>A plataforma como servi\u00e7o (PaaS) \u00e9 um modelo de computa\u00e7\u00e3o em nuvem que fornece uma plataforma para desenvolver, executar e gerenciar aplicativos sem a complexidade de construir e manter a infraestrutura normalmente associada ao desenvolvimento e lan\u00e7amento de aplicativos.</p> <p></p> <p>Durante o desenvolvimento, utilizamos PaaS da AWS de v\u00e1rias formas:</p> <ol> <li>Amazon Relational Database Service (RDS)</li> <li>O servi\u00e7o de banco de dados PostgreSQL foi gerenciado pelo RDS, eliminando a necessidade de configurar e manter servidores de banco de dados.</li> <li> <p>Configuramos par\u00e2metros de backup e alta disponibilidade diretamente na console do RDS, garantindo persist\u00eancia e durabilidade dos dados.</p> </li> <li> <p>Amazon Elastic Kubernetes Service (EKS)</p> </li> <li>Embora o EKS seja considerado um servi\u00e7o gerenciado de Kubernetes (conhecido como Kubernetes como servi\u00e7o), ele tamb\u00e9m se encaixa no modelo PaaS pois a AWS gerencia o plano de controle do cluster.</li> <li> <p>Utilizamos o EKS para orquestrar os microservi\u00e7os sem precisar provisionar a inst\u00e2ncia do plano mestre nem gerenciar upgrades de vers\u00e3o do Kubernetes manualmente.</p> </li> <li> <p>Amazon Elastic Container Registry (ECR)</p> </li> <li>Em vez de hospedar um reposit\u00f3rio Docker local ou auto-hospedado, utilizamos o ECR para versionar e armazenar as imagens dos microservi\u00e7os.</li> <li>As pipelines do Jenkins fazem o push das imagens diretamente para o ECR, que oferece integra\u00e7\u00e3o nativa com o EKS.</li> <li>Com o ECR, n\u00e3o precisamos configurar servidores extras para registros de container.</li> </ol> <p>Essas escolhas de PaaS reduziram o overhead operacional e permitiram que foc\u00e1ssemos em codifica\u00e7\u00e3o, monitora\u00e7\u00e3o e escalabilidade do cluster EKS.</p>"},{"location":"projeto/#video-de-demonstracao","title":"V\u00eddeo de Demonstra\u00e7\u00e3o","text":"<p>A seguir, nosso v\u00eddeo de demonstra\u00e7\u00e3o, mostrando o projeto em funcionamento:</p> <p> Clique na imagem acima para ver o v\u00eddeo.</p>"},{"location":"individual/exchange/","title":"Exchange API","text":"<p>A Exchange API foi desenvolvida com FastAPI em Python e tem como objetivo permitir a convers\u00e3o entre moedas por meio de um endpoint REST autenticado. As cota\u00e7\u00f5es s\u00e3o obtidas em tempo real utilizando a ExchangeRate-API, com valores atualizados diretamente da web.</p>"},{"location":"individual/exchange/#endpoint-principal","title":"Endpoint principal","text":"<p><code>GET /exchange/{from}/{to}</code></p>"},{"location":"individual/exchange/#exemplo-de-resposta","title":"Exemplo de resposta","text":"<pre><code>{\n  \"sell\": 0.82,\n  \"buy\": 0.80,\n  \"date\": \"2021-09-01 14:23:42\",\n  \"id-account\": \"0195ae95-5be7-7dd3-b35d-7a7d87c404fb\"\n}\n</code></pre>"},{"location":"individual/exchange/#autenticacao","title":"Autentica\u00e7\u00e3o","text":"<p>O acesso a este endpoint exige autentica\u00e7\u00e3o com token JWT, que \u00e9 validado pelo API Gateway antes de encaminhar a requisi\u00e7\u00e3o ao microservi\u00e7o Exchange.</p>"},{"location":"individual/exchange/#diagrama-de-integracao-com-gateway","title":"Diagrama de Integra\u00e7\u00e3o com Gateway","text":""},{"location":"individual/jenkins/","title":"Jenkins","text":"<p>Nesta fase do projeto, o objetivo era criar pipelines no Jenkins, conectando cada reposit\u00f3rio de microsservi\u00e7o para automatizar o build e a publica\u00e7\u00e3o das imagens Docker.</p>"},{"location":"individual/jenkins/#interface-jenkins","title":"Interface Jenkins","text":"<p>A seguir, temos a vis\u00e3o geral da interface do Jenkins com os jobs configurados:</p> <p>Dashboard do Jenkins </p> <p>Cada servi\u00e7o (interface ou service) foi adicionado como um pipeline separado.</p>"},{"location":"individual/jenkins/#credencial-docker-hub","title":"Credencial Docker Hub","text":"<p>Para permitir o push autom\u00e1tico de imagens Docker, foi configurada uma credencial do tipo Username + Password com o ID <code>dockerhub-credential</code>, conforme a imagem abaixo:</p> <p>Credential configurada </p>"},{"location":"individual/jenkins/#jenkinsfile-interfaces","title":"Jenkinsfile (Interfaces)","text":"<p>As interfaces (como <code>product</code>, <code>order</code>, <code>account</code>) utilizam um Jenkinsfile simples para build Maven:</p> <pre><code>pipeline {\n    agent any\n\n    stages {\n        stage('Build') {\n            steps {\n                sh 'mvn -B -DskipTests clean install'\n            }\n        }\n    }\n}\n</code></pre> <p>Este pipeline compila o c\u00f3digo e garante que as depend\u00eancias estejam corretas, mas n\u00e3o realiza deploy de imagens.</p>"},{"location":"individual/jenkins/#jenkinsfile-services","title":"Jenkinsfile (Services)","text":"<p>Para os services (como <code>order-service</code>, <code>product-service</code>, etc.), o Jenkinsfile realiza tamb\u00e9m o build da imagem Docker e seu push para o Docker Hub:</p> <pre><code>ppipeline {\n    agent any\n    environment {\n        SERVICE = 'order-service'\n        NAME = \"henriquetg1/${env.SERVICE}\"\n    }\n    stages {\n        stage('Dependecies') {\n            steps {\n                build job: 'order', wait: true\n            }\n        }\n        stage('Build') { \n            steps {\n                sh 'mvn -B -DskipTests clean package'\n            }\n        }      \n        stage('Build &amp; Push Image') {\n            steps {\n                withCredentials([usernamePassword(credentialsId: 'dockerhub-credential', usernameVariable: 'USERNAME', passwordVariable: 'TOKEN')]) {\n                    sh \"docker login -u $USERNAME -p $TOKEN\"\n                    sh \"docker buildx create --use --platform=linux/arm64,linux/amd64 --node multi-platform-builder-${env.SERVICE} --name multi-platform-builder-${env.SERVICE}\"\n                    sh \"docker buildx build --platform=linux/arm64,linux/amd64 --push --tag ${env.NAME}:latest --tag ${env.NAME}:${env.BUILD_ID} -f Dockerfile .\"\n                    sh \"docker buildx rm --force multi-platform-builder-${env.SERVICE}\"\n                }\n            }\n        }\n    }\n}\n</code></pre> <p>Esse pipeline compila, empacota, constr\u00f3i e publica a imagem usando multi-platform Docker build.</p>"},{"location":"individual/minikube/","title":"MiniKube","text":""},{"location":"individual/minikube/#objetivo","title":"Objetivo","text":"<p>Executar todos os microservi\u00e7os em um cluster Kubernetes local usando o Minikube, reproduzindo um ambiente de orquestra\u00e7\u00e3o completo.</p>"},{"location":"individual/minikube/#pre-requisitos","title":"Pr\u00e9-Requisitos","text":"<ul> <li>Docker instalado e rodando</li> <li>Minikube instalado</li> <li>kubectl instalado</li> </ul>"},{"location":"individual/minikube/#passos-para-iniciar","title":"Passos para iniciar","text":""},{"location":"individual/minikube/#1-iniciar-o-minikube","title":"1. Iniciar o Minikube","text":"<p>No terminal, rode:</p> <pre><code>minikube start --driver=docker\n</code></pre>"},{"location":"individual/minikube/#2-clonar-e-navegar-ate-o-projeto","title":"2. Clonar e navegar at\u00e9 o projeto","text":"<pre><code>cd platforma/api/k8s\n</code></pre> <p>Esse diret\u00f3rio cont\u00e9m os arquivos YAML de <code>deployment</code> e <code>service</code> para:</p> <ul> <li><code>account-service</code></li> <li><code>auth-service</code></li> <li><code>exchange-service</code></li> <li><code>gateway-service</code></li> <li><code>order-service</code></li> <li><code>product-service</code></li> <li><code>postgres-service</code></li> </ul>"},{"location":"individual/minikube/#3-aplicar-todos-os-arquivos","title":"3. Aplicar todos os arquivos","text":"<pre><code>kubectl apply -f .\n</code></pre> <p>Esse comando l\u00ea todos os arquivos <code>.yml</code> do diret\u00f3rio atual e sobe os pods e servi\u00e7os no cluster.</p>"},{"location":"individual/minikube/#4-verificar-status","title":"4. Verificar status","text":""},{"location":"individual/minikube/#pods","title":"Pods","text":"<pre><code>kubectl get pods\n</code></pre>"},{"location":"individual/minikube/#servicos","title":"Servi\u00e7os","text":"<pre><code>kubectl get service\n</code></pre>"},{"location":"individual/minikube/#retorno-esperado","title":"Retorno Esperado:","text":""},{"location":"individual/minikube/#acessando-a-aplicacao","title":"Acessando a aplica\u00e7\u00e3o","text":"<p>Se quiser acessar algum servi\u00e7o (ex: <code>gateway-service</code>) localmente via browser:</p> <pre><code>minikube service gateway-service\n</code></pre> <p>Isso abre automaticamente o servi\u00e7o no navegador com um t\u00fanel tempor\u00e1rio via Minikube.</p>"},{"location":"individual/minikube/#arquitetura-do-k8s","title":"Arquitetura do <code>k8s/</code>","text":"<pre><code>k8s/\n\u251c\u2500 account-service/\n   \u251c\u2500 k8s.yaml \n\u251c\u2500 auth-service/\n   \u251c\u2500 k8s.yaml \n\u251c\u2500 gateway-service/\n   \u251c\u2500 k8s.yaml \n\u251c\u2500 order-service/\n   \u251c\u2500 k8s.yaml \n\u251c\u2500 postgres-service/\n   \u251c\u2500 configmap.yaml \n   \u251c\u2500 deployment.yaml \n   \u251c\u2500 secrets.yaml \n   \u251c\u2500 service.yaml \n\u2514\u2500 product-service/\n   \u251c\u2500 k8s.yaml \n</code></pre>"},{"location":"individual/order/","title":"Order API","text":"<p>O Order API foi desenvolvido em Spring Boot (Java) e fornece um conjunto de endpoints REST para gerenciar pedidos de uma loja. Todas as requisi\u00e7\u00f5es passam pelo API Gateway, que valida o token JWT antes de encaminhar ao servi\u00e7o.</p>"},{"location":"individual/order/#endpoints-principais","title":"Endpoints Principais","text":"<p>Criar novo pedido - POST <code>/order</code> - Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre> - Request Body (JSON): <pre><code>{\n      \"items\": [\n          {\n              \"idProduct\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n              \"quantity\": 2\n          },\n          {\n              \"idProduct\": \"0195abfe-e416-7052-be3b-27cdaf12a984\",\n              \"quantity\": 1\n          }\n      ]\n  }   \n</code></pre> - Response (JSON \u2014 c\u00f3digo HTTP 201 Created): <pre><code>{\n      \"id\": \"0195ac33-73e5-7cb3-90ca-7b5e7e549569\",\n      \"date\": \"2025-09-01T12:30:00\",\n      \"items\": [\n          {\n              \"id\": \"01961b9a-bca2-78c4-9be1-7092b261f217\",\n              \"product\": {\n                  \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\"\n              },\n              \"quantity\": 2,\n              \"total\": 20.24\n          },\n          {\n              \"id\": \"01961b9b-08fd-76a5-8508-cdb6cd5c27ab\",\n              \"product\": {\n                  \"id\": \"0195abfe-e416-7052-be3b-27cdaf12a984\"\n              },\n              \"quantity\": 10,\n              \"total\": 6.2\n          }\n      ],\n      \"total\": 26.44\n  }\n</code></pre></p> <p>Listar todos os pedidos - GET <code>/order</code> - Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre> - Response (JSON Array \u2014 c\u00f3digo HTTP 200 OK): <pre><code>  [\n      {\n          \"id\": \"0195ac33-73e5-7cb3-90ca-7b5e7e549569\",\n          \"date\": \"2025-09-01T12:30:00\",\n          \"total\": 26.44\n      },\n      {\n          \"id\": \"0195ac33-cbbd-7a6e-a15b-b85402cf143f\",\n          \"date\": \"2025-10-09T03:21:57\",\n          \"total\": 18.6\n      }\n  ]\n</code></pre></p> <p>Obter pedido por ID - GET <code>/order/{id}</code> - Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre> - Response (JSON \u2014 c\u00f3digo HTTP 200 OK): <pre><code>  {\n      \"id\": \"0195ac33-73e5-7cb3-90ca-7b5e7e549569\",\n      \"date\": \"2025-09-01T12:30:00\",\n      \"items\": [\n          {\n              \"id\": \"01961b9a-bca2-78c4-9be1-7092b261f217\",\n              \"product\": {\n                  \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n              },\n              \"quantity\": 2,\n              \"total\": 20.24\n          },\n          {\n              \"id\": \"01961b9b-08fd-76a5-8508-cdb6cd5c27ab\",\n              \"product\": {\n                  \"id\": \"0195abfe-e416-7052-be3b-27cdaf12a984\",\n              },\n              \"quantity\": 10,\n              \"total\": 6.2\n          }\n      ],\n      \"total\": 26.44\n  }\n</code></pre> - Caso o pedido n\u00e3o exista: retorna 404 Not Found com corpo vazio.</p>"},{"location":"individual/order/#autenticacao","title":"Autentica\u00e7\u00e3o","text":"<ul> <li>Todas as chamadas aos endpoints acima exigem um token JWT v\u00e1lido.  </li> <li>O token deve ser produzido pelo Auth Service e passado no cabe\u00e7alho:</li> </ul>"},{"location":"individual/order/#diagrama-de-integracao-com-gateway","title":"Diagrama de Integra\u00e7\u00e3o com Gateway","text":""},{"location":"individual/order/#testes-das-rotas-com-postman","title":"Testes das rotas com Postman","text":"<p>Teste com cria\u00e7\u00e3o de um pedido </p> <p>Teste para ver todos os pedidos cadastrados </p> <p>Teste para ver um pedido cadastrado espec\u00edfico </p>"},{"location":"individual/product/","title":"Product API","text":"<p>O Product API foi desenvolvido em Spring Boot (Java) e fornece um conjunto de endpoints REST para gerenciar produtos de uma loja. Todas as requisi\u00e7\u00f5es passam pelo API Gateway, que valida o token JWT antes de encaminhar ao servi\u00e7o.</p>"},{"location":"individual/product/#endpoints-principais","title":"Endpoints Principais","text":"<p>Criar novo produto    - POST <code>/product</code>    - Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre>    - Request Body (JSON): <pre><code>{\n  \"name\": \"Tomate\",\n  \"price\": 10.12,\n  \"unit\": \"kg\"\n}\n</code></pre>    - Response (JSON \u2014 c\u00f3digo HTTP 201 Created): <pre><code>{\n  \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n  \"name\": \"Tomate\",\n  \"price\": 10.12,\n  \"unit\": \"kg\"\n}\n</code></pre></p> <p>Listar todos os produtos    - GET <code>/product</code>    - Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre>    - Response (JSON Array \u2014 c\u00f3digo HTTP 200 OK): <pre><code>[\n  {\n    \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n    \"name\": \"Tomate\",\n    \"price\": 10.12,\n    \"unit\": \"kg\"\n  },\n  {\n    \"id\": \"0195abfe-e416-7052-be3b-27cdaf12a984\",\n    \"name\": \"Queijo\",\n    \"price\": 0.62,\n    \"unit\": \"fatia\"\n  }\n]\n</code></pre></p> <p>Obter produto por ID    - GET <code>/product/{id}</code>    - Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre>    - Response (JSON \u2014 c\u00f3digo HTTP 200 OK): <pre><code>{\n  \"id\": \"0195abfb-7074-73a9-9d26-b4b9fbaab0a8\",\n  \"name\": \"Tomate\",\n  \"price\": 10.12,\n  \"unit\": \"kg\"\n}\n</code></pre>    - Caso o produto n\u00e3o exista: retorna 404 Not Found com corpo vazio.  </p> <p>Deletar produto por ID    - DELETE <code>/product/{id}</code>    - Headers: <pre><code>Authorization: Bearer &lt;token-JWT&gt;\n</code></pre>    - Response:      - 204 No Content se o produto existir e for removido com sucesso.      - 404 Not Found se n\u00e3o encontrar o produto.  </p>"},{"location":"individual/product/#autenticacao","title":"Autentica\u00e7\u00e3o","text":"<ul> <li>Todas as chamadas aos endpoints acima exigem um token JWT v\u00e1lido.  </li> <li>O token deve ser produzido pelo Auth Service e passado no cabe\u00e7alho:</li> </ul>"},{"location":"individual/product/#diagrama-de-integracao-com-gateway","title":"Diagrama de Integra\u00e7\u00e3o com Gateway","text":""},{"location":"individual/product/#testes-das-rotas-com-postman","title":"Testes das rotas com Postman","text":"<p>Teste com cria\u00e7\u00e3o de um produto Teste para ver todo os produtos cadastrados Teste para ver um produto cadastrado espec\u00edfico Teste para deletar um produto espec\u00edfico </p>"}]}